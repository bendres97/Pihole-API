/*
 * PiHole Management API
 *
 * A management webservice to be run locally on a PiHole instance
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"errors"
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
)

// DefaultAPIService is a service that implements the logic for the DefaultAPIServicer
// This service should implement the business logic for every endpoint for the DefaultAPI API.
// Include any external packages or services that will be required by this service.
type DefaultAPIService struct {
}

// NewDefaultAPIService creates a default api service
func NewDefaultAPIService() DefaultAPIServicer {
	return &DefaultAPIService{}
}

func (s *DefaultAPIService) OverridesListGet(ctx context.Context, list string) (ImplResponse, error) {
	var result cmdResp
	switch strings.ToLower(list) {
	case "allow":
		result = runCommand(PIHOLE_EXECUTABLE, []string{"-w", "-l"})
	case "block":
		result = runCommand(PIHOLE_EXECUTABLE, []string{"-b", "-l"})
	default:
		err := fmt.Errorf("'%v' is not a valid argument, options are 'allow' and 'block'", list)
		return Response(418, err.Error()), err
	}

	if result.err != nil {
		return Response(500, result.err.Error()), result.err
	}

	re := regexp.MustCompile(LIST_REGEX)
	listData := re.FindAllString(result.stdout, -1)
	log.Print("List Data: ", listData)

	return Response(500, "Not implemented"), errors.New("not implemented")

	// return Response(200, listData), nil

}

// StatusActionPost
func (s *DefaultAPIService) StatusActionPost(ctx context.Context, action string) (ImplResponse, error) {
	action = strings.ToLower(action)
	var command string
	switch action {
	case "restart":
		command = "restartdns"
	case "enable":
		command = "enable"
	case "disable":
		command = "disable"
	default:
		return Response(400, "Valid options are `restartdns`, `enable`, and `disable`"), errors.New("invalid request")
	}

	result := runCommand(PIHOLE_EXECUTABLE, []string{command})
	if result.err != nil {
		return Response(500, result.err.Error()), result.err
	}

	return s.StatusGet(ctx)
}

// StatusGet -
func (s *DefaultAPIService) StatusGet(ctx context.Context) (ImplResponse, error) {

	cmdResult := runCommand(PIHOLE_EXECUTABLE, []string{"status"})
	if cmdResult.err != nil {
		return Response(500, cmdResult.err.Error()), cmdResult.err
	}

	result := cmdResult.stdout

	status := Status{
		Listening: strings.Contains(result, "[✓] FTL is listening on port 53"),
		Blocking:  strings.Contains(result, "[✓] Pi-hole blocking is enabled"),
		Ipv4: UdpTcp{
			Tcp: strings.Contains(result, "[✓] TCP (IPv4)"),
			Udp: strings.Contains(result, "[✓] UDP (IPv4)"),
		},

		Ipv6: UdpTcp{
			Tcp: strings.Contains(result, "[✓] TCP (IPv6)"),
			Udp: strings.Contains(result, "[✓] UDP (IPv6)"),
		},
	}

	if status.Listening {
		if status.Blocking {
			return Response(200, status), nil
		} else {
			return Response(201, status), nil
		}
	} else {
		return Response(500, status), nil
	}
}

// GravityGet -
func (s *DefaultAPIService) GravityGet(ctx context.Context) (ImplResponse, error) {

	cmdResult := runCommand(SQLLITE_EXECUTABLE, []string{SQLLITE_DATABASE, "SELECT id, address, comment FROM adlist;"})
	if cmdResult.err != nil {
		return Response(500, cmdResult.err.Error()), cmdResult.err
	}

	var gravity []GravityObj

	result := strings.TrimSpace(cmdResult.stdout)
	lines := strings.Split(result, "\n")
	for _, line := range lines {
		split := strings.Split(line, "|")
		id_val, err := strconv.Atoi(split[0])
		if err != nil {
			return Response(500, err.Error()), err
		}
		id := int32(id_val)
		address := split[1]
		comment := split[2]
		gravity = append(gravity, GravityObj{
			Id:      id,
			Address: address,
			Comment: comment,
		})
	}

	return Response(200, gravity), nil
}

// GravityIdDelete -
func (s *DefaultAPIService) GravityIdDelete(ctx context.Context, id int32) (ImplResponse, error) {
	cmdResult := runCommand(SQLLITE_EXECUTABLE, []string{SQLLITE_DATABASE, fmt.Sprintf("DELETE FROM adlist WHERE id = %v", id)})
	if cmdResult.err != nil {
		return Response(500, cmdResult.err.Error()), cmdResult.err
	}

	return Response(200, "Domain deleted"), nil
}

// GravityPatch -
func (s *DefaultAPIService) GravityPatch(ctx context.Context) (ImplResponse, error) {
	cmdResult := runCommand(PIHOLE_EXECUTABLE, []string{"-g"})
	if cmdResult.err != nil {
		return Response(500, cmdResult.err.Error()), cmdResult.err
	}

	return Response(200, "Gravity Updated"), nil
}

// GravityPost -
func (s *DefaultAPIService) GravityPost(ctx context.Context, gravityObj GravityObj) (ImplResponse, error) {
	cmdResult := runCommand(
		SQLLITE_EXECUTABLE,
		[]string{SQLLITE_DATABASE,
			fmt.Sprintf("SELECT id, address, comment FROM adlist WHERE address = '%v';",
				gravityObj.Address),
		},
	)
	if cmdResult.err != nil {
		return Response(500, cmdResult.err.Error()), cmdResult.err
	}

	result := strings.TrimSpace(cmdResult.stdout)
	if len(result) > 0 {
		lines := strings.Split(result, "\n")
		for _, line := range lines {
			split := strings.Split(line, "|")
			id_val, err := strconv.Atoi(split[0])
			if err != nil {
				return Response(500, err.Error()), err
			}
			id := int32(id_val)
			address := split[1]
			comment := split[2]
			gravity := GravityObj{
				Id:      id,
				Address: address,
				Comment: comment,
			}
			if len(lines) > 1 {
				return Response(500, nil), fmt.Errorf("more than one result found for '%v'", address)
			} else if len(lines) == 1 {
				if address == gravityObj.Address && comment == gravityObj.Comment {
					return Response(200, gravity), nil
				} else {
					updatecmd := runCommand(
						SQLLITE_EXECUTABLE,
						[]string{
							SQLLITE_DATABASE,
							fmt.Sprintf(
								"UPDATE adlist SET address = '%v', comment = '%v' WHERE id = %v",
								gravity.Address,
								gravity.Comment,
								id,
							),
						},
					)

					if updatecmd.err != nil {
						return Response(500, updatecmd.err.Error()), updatecmd.err
					}
					gravity.Address = gravityObj.Address
					gravity.Comment = gravityObj.Comment
					gravity.Id = id
					return Response(201, gravity), nil
				}
			}
		}

	} else {
		insertcmd := runCommand(
			SQLLITE_EXECUTABLE,
			[]string{
				SQLLITE_DATABASE,
				fmt.Sprintf(
					"INSERT INTO adlist (address, comment) VALUES ('%v','%v')",
					gravityObj.Address,
					gravityObj.Comment,
				),
			},
		)
		if insertcmd.err != nil {
			return Response(500, insertcmd.err.Error()), insertcmd.err
		}

		checkcmd := runCommand(
			SQLLITE_EXECUTABLE,
			[]string{
				SQLLITE_DATABASE,
				fmt.Sprintf(
					"SELECT id, address, comment FROM adlist WHERE address = '%v';",
					gravityObj.Address,
				),
			},
		)
		if checkcmd.err != nil {
			return Response(500, checkcmd.err.Error()), checkcmd.err
		}
		return Response(200, gravityObj), nil
	}
	return Response(500, "Unknown Error"), errors.New("reached end of method unexpectedly")
}

// RecordsDelete
func (s *DefaultAPIService) RecordsDelete(ctx context.Context, record DeleteRecord) (ImplResponse, error) {

	// Get existing list based on type of record
	var existing []Record
	var err error
	if record.Type == "A" {
		existing, err = getA()
	} else if record.Type == "CNAME" {
		existing, err = getCNAME()
	} else {
		err = fmt.Errorf("'%v' is not a valid record type", record.Type)
		return Response(418, err.Error()), err
	}
	if err != nil {
		return Response(500, err.Error()), err
	}

	// Iterate through records and determine if deletion is necessary
	var writeback []Record
	var found bool
	for _, entry := range existing {
		if entry.Domain == record.Domain {
			found = true
		} else {
			writeback = append(writeback, entry)
		}
	}

	// If the domain was found, write back the records with the domain removed

	if found {
		if record.Type == "A" {
			err := writeA(writeback)
			if err != nil {
				return Response(500, err.Error()), err
			}
		} else if record.Type == "CNAME" {
			err := writeCNAME(writeback)
			if err != nil {
				return Response(500, err.Error()), err
			}
		}
		return Response(201, fmt.Sprintf("Domain '%v' was removed", record.Domain)), nil

	} else {
		return s.RecordsGet(ctx)
	}
}

// RecordsGet
func (s *DefaultAPIService) RecordsGet(ctx context.Context) (ImplResponse, error) {
	cname, err := getCNAME()
	if err != nil {
		return Response(500, err.Error()), err
	}

	typeA, err := getA()
	if err != nil {
		return Response(500, err.Error()), err
	}

	records := append(cname, typeA...)

	return Response(200, records), nil
}

// RecordsPost
func (s *DefaultAPIService) RecordsPost(ctx context.Context, record Record) (ImplResponse, error) {
	// Get existing list based on type of record
	var existing []Record
	var err error
	if record.Type == "A" {
		existing, err = getA()
	} else if record.Type == "CNAME" {
		existing, err = getCNAME()
	} else {
		err = fmt.Errorf("'%v' is not a valid record type", record.Type)
		return Response(418, err.Error()), err
	}
	if err != nil {
		return Response(500, err.Error()), err
	}

	for _, entry := range existing {
		if record.Domain == entry.Domain && record.Destination == entry.Destination {
			return s.RecordsGet(ctx)
		}
	}

	writeback := append(existing, record)
	if record.Type == "A" {
		err = writeA(writeback)
	} else if record.Type == "CNAME" {
		err = writeCNAME(writeback)
	} else {
		err = fmt.Errorf("'%v' is not a valid record type", record.Type)
		return Response(418, err.Error()), err
	}
	if err != nil {
		return Response(500, err.Error()), err
	}

	new, err := s.RecordsGet(ctx)
	if err != nil {
		return Response(500, err.Error()), err
	}
	return Response(201, new.Body), nil

}
